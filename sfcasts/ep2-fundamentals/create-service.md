# Create Service

We know that bundles give us services and services do work. So if we need to write our own custom code that does work, can we put that into our own service? Absolutely! And it's also a great way to organize your code, allow your logic to be reused, and will let you unit test your code if you want to. We're *already* doing some work in our app in the `browse` action. We make the HTTP request and cache the result. Putting this logic in our controller is *fine*, but by moving it into its own service class, it'll make the code more clear and reusable. So let's do it! How do we create a service? In the `/src` directory, create a new PHP class *wherever* you want. It doesn't matter how you organize things or what sub-directories you create. Most of the time, I'll have a `/Service` directory. And inside of *that*, let's create a new PHP class I'll call... how about `MixRepository`. "Repository" is a pretty common name for a service that returns data. Notice that when I create this, PhpStorm *automatically* adds the correct namespace. It doesn't matter *how* we organize our services inside of `/src`, as long as our namespace matches our directory.

One important thing about service classes is that they have *nothing* to do with Symfony. Our controller class is a Symfony concept, but `MixRepository` is a class we're *creating* to *organize* our own logic. That means there aren't any rules. We don't need to extend a base class or implement an interface. We can make this class look and feel however we want.

With that in mind, let's create a new `public function` called `findAll()` that will `return` an `array` of all of the mixes in our system. Back in `VinylController.php`, copy all of the logic that fetches `$mixes` and paste that over here. PhpStorm will ask you if you want to add a `use` statement for the `CacheItemInterface`. Hit "OK" to add that on top. Then, instead of creating a `$mixes` variable, let's just `return` this. There *are* some undefined variables in this class. Don't worry about these *yet*. I first want to see if we can *use* our `MixRepository`. In order to do that, inside of `VinylController,php`, we need to add it to Symfony's container so we can autowire it like we did with `HtttpClientInterface` and `CacheInterface`. Spin over to your terminal and run:

```terminal
php bin/console debug:autowiring --all
```

Scroll up to the top and... surprise! Our `MixRepository` is *already* a service in the container. Let me explain two things here. First, the `--all` flag is not *that* important. It basically tells this command to show you the core services like `$httpClient` and `$cache`, *plus* our own services like `MixRepository`. Second, the container *somehow* already saw our repository class and recognized it as a service. How did that happen? We'll learn about that in a few minutes, but for now, it's enough to know that our new `MixRepository` is already inside the container, which means we can autowire it. Back over in our controller, let's add a third argument type hint for `MixRepository` and call it... how about `$mixRepository`. Then, down here, we don't need any of this `$mixes` code anymore. We can simply say `$mixes = $mixRepository->findAll()`. How nice is that?

All right, let's try it! Refresh and... yes! We get an `Undefined variable $cache` message coming from our `MixRepository`, but *it works*. The fact that our code got here means that when we autowire `$mixRepository`, the container *instantiated* our `MixRepository` and passed it to us so that we could then call a method on it.

We created a service and made it available for autowiring. Cool! But our new service needs the `$httpClient` and `$cache` services in order to do its work. Can we get those from inside of here? The answer is one of the most important concepts in Symfony and object-oriented coding in general: Dependency injection. Let's talk about that next.
