# Query Builder

The `/browse` page is working, but what if we click on one of these genres? Well... it *kind of* works. It shows the name of the genre, but no matter what we click, we just get all of the mixes. What we *really* want is to filter these mixes by genre and only show the ones that match. Right now, all of the mixes are in the "Pop" genre, so to make our data a little more interesting, head back into `MixController.php`, find our fake method that creates new mixes, and let's create a `$genres` variable with "Pop" *and* "Rock" included.

We'll start by randomly choosing one of those genres with `$mix->setGenre()`. Then we'll say `$genres` and we can use use `array_rand($genres)`. Cool! Now we can go to `/mix/new`, refresh this a few times so we get about 15 mixes, and then, back on the `/browse` page... yes! We have a mix of some "Rock" and some "Pop" in here, but it *still* doesn't filter correctly.

So how can we customize the query to *only* return the results for a certain genre? We can actually do that in `VinylController.php` via this `findBy()` method. The genre is in the URL as this `$slug` wild card, so we can use this to our advantage. We *could* add an "if" statement so we can query where the `genre` matches the `$slug`. *But* this is a great opportunity to learn how to create custom queries, so let me undo that. When you want to create a custom query, you're going to do that in the repository. If we need to query for the `VinylMix` entity, for example, we're going to do that in `VinylMixRepository.php`. There are already a few example methods in here with custom queries. Let's un-comment the first one, and then start *simple*. I'm going to say `findAllOrderedByVotes()`. We won't worry about the genre at all yet. I just want to make a query that returns all of the mixes ordered by votes. I'll also remove that argument. This is going to return an array and the PHP documentation up here helps it know that it's going to be an array of `VinylMix` objects.

There are a few different ways to create a custom query in Doctrine. Doctrine eventually makes SQL queries, but it works with MySQL and Postgres SQL, and all of the SQL for each of those look a little different. Internally, Doctrine has its own query language (which will feel very familiar) called Doctrine Query Language or "DQL". If you saw DQL as a string, it would look something like `SELECT * FROM vinyl_mix`. So you *can* write this string DQL by hand, but it's more common to create something called a "QueryBuilder", which is this nice object that helps you build a query step-by-step.

Let's do that. We can start with `$this->createQueryBuilder()`, and then this first argument is going to be the alias. This could be anything, but let's say `mix`. Since we're in the `VinylMixRepository`, it knows we're going to query from the `vinyl_mix` table. So, once again, this is basically like `SELECT * FROM vinyl_mix AS mix`.

Then, one of the methods we can call here is `->orderBy()`, and we can pass this `mix`, since that's our alias, with `.votes`. I'll follow this with `DESC`, and *that's it*. When we're done with the QueryBuilder, we always call `->getQuery()` (that turns it into a query object), and then `->getResult()`.

There are a number of methods you can call in here to get the results. The main two that you need to know about are `getResult()`, which returns an array of results, or `getOneOrNullResult()`, which is what you would use if you were querying for a specific vinyl mix. It would return that *one* object or "null". In our case, we want to return the array of results, so we'll use `getResult()`.

All right, let's try that! Over in `VinylController.php` (let me close `MixController.php`...), instead of `findBy()`, we're going to call `findAllOrderedByVotes()`. *Immediately*, I love how clear that method is. I can see *exactly* what I'm querying for. And when we try it... it still works! It's not filtering yet, but you can see that the order is correct.

Okay, on our new method, let's add an optional `string $genre` argument. Say `string $genre = null`, and then, if the genre is passed, we're going to add a "where" statement. I'm going to break this statement onto multiple lines, and then I'll replace this `return` with `$queryBuilder =`. Below, we'll say `return $queryBuilder` with `->getQuery()`, and `->getResult()`.

So far, this makes *no* change. We're just breaking this onto multiple lines. *Now*, we can say `if ($genre)`, and we'll add our "where" statement. How do we do that? It's a method on our QueryBuilder! Say `$queryBuilder->andWhere()`.

A word of warning here: There's *also* a `where()` method. I *never* use that method. When you call `where()`, it will clear out any other "where" statements you might have, so you might accidentally *remove* a "where" statement that you added earlier. *Always* use `andWhere()`. And even though we don't have a "where" statement yet, Doctrine is smart enough to figure that out and avoid causing an error.

Inside of the `andWhere()`, we'll pass `mix.genre =`, but we don't actually put the genre right here. That is a *huge* no-no. Never *ever* do that. That opens you up for SQL injection attacks and that is *bad news*. Instead, whenever you put a dynamic value into a query, you always use a prepared statement, which is a fancy way of saying that you put a little placeholder here, like `:genre`, and the name of this could be *anything*. You could call it "dinosaur" if you want, but whatever you put here, you'll then fill in the placeholder by saying `->setParameter()` with the *name* of the parameter - so `genre` - and then whatever value that needs - in our case, our *dynamic* `$genre`. Beautiful! Now, over in `VinylController.php`, we can pass our `$slug` genre.

Okay, let's try this! I'm going to click back to the `/browse` page first. Awesome! We get all of the results. Now we'll click "Rock" and... nice! Less results, and the genre is only "Rock"! If I filter by "Pop"... awesome! And we can even see the query for this if we want to. Here it is, and it's got the "where" statement for the genre, equaling "Pop". Woo!

As your project gets bigger and bigger, you're going to create more and more custom methods in here for custom queries. And you may find that you start repeating the same query logic over and over again. For example, we might eventually order by the votes in a bunch of different methods inside of this repository. To avoid duplication, we can isolate this into a private method. Check this out! We can say `private function addOrderByVotesQueryBuilder()`, and then this will accept a `QueryBuilder` argument (we want the one from `Doctrine\ORM`), but let's make it *optional*. And this method itself will return a `QueryBuilder`.

The job of this method will be to basically add this `->orderBy()` line here. We can pass it a `$queryBuilder` that it will modify, and if we don't, it will just create a new one. So we can start here by saying `$queryBuilder = $queryBuilder ?? $this->createQueryBuilder()`, and we want to use that same `mix` alias every time we create a QueryBuilder. This might look a little weird, but it basically says "If there *is* a QueryBuilder, then just use it. Else, create a new one".

Then, down here, we'll say `return $queryBuilder`, and I'm going to go steal this `->orderBy()` logic from up here and... paste. Awesome! And you can see that PhpStorm is a little angry with me right now. This is just because my PhpStorm is erroring out and needs to be restarted. So if you're a little confused by PhpStorm here, that's what's happening.

Anyway, up here, we can simply say `$queryBuilder = $this->addOrderByVotesQueryBuilder()` and we'll pass it *nothing*. It will create that QueryBuilder for us, add the `orderBy()`, and when we refresh... that *still* works.

Next, let's add a "mix show" page where we can view a *single* vinyl mix. For the first time, we'll query for a single object from the database, and deal with what happens if *no* matching mix is found.
