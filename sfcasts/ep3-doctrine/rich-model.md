# Rich Model

After we submit a form successfully, we *always* redirect. Often times, we'll also want to show the user a success message after the redirect so they *know* the form was submitted. Symfony has a special way to handle this: *Flash messages*.

Before we redirect, we can use a shortcut method on the base controller called `addFlash()`. Say `$this->addFlash()` and pass this `success`. For the second argument, we can add the message we want to show to the user: `Vote counted!`. The `success` key could be anything. It's kind of like a category for the flash message, and you'll see how we use that in a minute.

Flash messages have a fancy name, but they're a simple idea; They store the message in the user's session. What makes flash messages special is that it will *automatically* be removed after we read this message one time. They're like self-destructing messages, which is pretty cool.

So... how do we read them? The way I like to do it is by opening up my base template - `base.html.twig` - and reading and rendering them here. Let's put it right after the navigation and before the `{% block body %}`. Say `{% for message in %}`. Then what we want to do is read out any `success` category flash messages we might have. To do this, we can leverage the one global variable we have in Symfony, which is called `app`. This has several methods on it, like `environment`, `request`, `session`, the current `user`, or one called `app.flashes`. This is a method where we pass it the *category* (in our case,`success`). As I mentioned, this could be *anything*. You *could* put "dinosaur" here, and if you did that in a controller, you'd read the "dinosaur" messages out *there*. At the end, we'll say `{% endfor %}`. Typically, you'll only have *one* success message in your flash at a time, but *technically* you can have multiple. That's why we're looping over them.

Inside of this, let's render a `<div>` with `class="alert alert-success"` so it looks like a happy message. Inside of *that*, we'll print out `{{ message }}`. So if this works correctly, it will read all of our `success` flash messages and then render them. Once they've been read, they'll be removed and won't render again. By putting this in the base template, we can now set flash messages from *anywhere* in our system and they'll be rendered right on the page. Check it out! Head back to our page, upvote and... beautiful! We'll probably want to remove this extra margin here in a real project, but we'll leave it for now.

All right, look back at `MixController.php`. The logic for doing our "up" and "down" voting is pretty simple, but I think it could be more clear. Try this! Open up `VinylMix.php` and scroll down to find `setVotes`. Right after this, just to keep things organized, create a new `public function` called `upVote()` and return `void`. Inside, say `$this->votes++`, copy that, and create a *second* method which we'll call - you guessed it - `downVote()` with `$this->votes--`. Thanks to these methods, in `MixController.php`, instead of having `$mix->setVotes()` set to `$mix getVotes() + 1`, we can just say `$mix->upVote()` and `$mix->downVote()`. Now *that's* nice. Our controller reads much more clearly, and we've encapsulated the `upVote()` and `downVote()` logic into the entity. If we head over and refresh, it *still* works.

Okay, this highlights an important topic. We've added *three* custom methods to our entity. One that helps read the data in a special way, and two that help *set* the data. When we run `make:entity`, it creates getter and setter methods for every single property. That's nice, because it makes our entity *infinitely* flexible. *Anyone* from *anywhere* can read or set any property. But sometimes, you might *not* want or need that. For example, do we really want a `setVotes()` method? Is there really a use case in our code for something to set the vote count to *any* number that it wants? Probably not. We'll likely only need `upVote()` and `downVote()`. I will keep the `setVotes()` method for now, though, because we'll use it when we generate our dummy vinyl mix.

But this touches on a really interesting idea. By removing unnecessary getter and setter methods in your entity and replacing them with more descriptive methods like `upVote()`, `downVote()`, `getVoteString()`, or `getImageUrl()` - methods that fit your business logic - you can, little by little, give your entities more clarity. Our `upVote()` and `downVote()` methods are super clear and descriptive. Someone calling these doesn't even need to know or *care* how they work internally.

Entities that *only* have getter and setter methods are sometimes called "anemic models". Entities that *remove* these and replace them with specific methods for your business logic are sometimes called "smart models". Some people take this to an extreme and have almost *no* getter or setter methods. Here at SymfonyCasts, we tend to be more pragmatic. We usually do have getter and setter methods, but we always look for ways to be more descriptive, like `upVote()` and `downVote()`.

Next, let's install an *awesome* library called DoctrineExtensions. This is a magic library full of superpowers, like automatic, timestampable, and slug creation behaviors.
