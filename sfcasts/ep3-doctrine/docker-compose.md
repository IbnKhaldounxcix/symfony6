# docker-compose

Coming soon...

We need to get a database running my SQL Postgre SQL, whatever. If you already have one running awesome, all you need to do is copy your database, underscore environment variable open, or create a dot M dot local file or create a M lo file pace there, and then just change it for whatever your actual parameters use an M parameter port are. And if you wanna do that, do it, and then go ahead and skip forward. I, for me, <affirmative>, for me, I do not have a database running locally on my system, and I'm not going to install one. Instead. I want to use Docker. We're actually gonna use Docker in kind of an interesting way. I do have PHP installed locally, so we won't use Docker and create a Docker container specifically for PHP. Instead we'll simply use Docker to help boot up services like a database service Docker makes that super easy, especially with some tricks, we'll learn about the symphony binary. Oh, and remember when the doctrine recipe asked us if we wanted Docker configuration, because we said, yes, we got a Docker composed and dock ride override dot Yamo file. When Docker boots, it will actually read both of these files. The reason they're split into two pieces, isn't really important.

It's important only if you were planning to use Docker for production, we're gonna use just Docker, just locally. So what this says is it's going to boot up a single container, which is going to be, which is gonna run a Postgres database. It'll create a database called app with a user called symphony and password change me unless we override those by setting other environment variables, which we want. It also is going to expose the port 5 43, 2 that's Postgres, normal port to our host machine on a random port. So what that means is we are gonna be able to talk to our Postgres Docker container through, through a random port. And we'll see how that works in a second. By the way, if you wanna use a MySQL instead of Postgres, you can absolutely. You can go ahead and update these used MySQL, or you could delete both of these files and use the bin console, make database to generate new ones for my SQL or Maria DB. All right, but I'm gonna use Postgres because it is awesome. So let's get our container running through that. We're gonna run Docker compose. I need to also make sure people have Docker installed up dash D dash D means to run in the background as the Damon, first time you run this, we'll probably have to download some stuff, but then it works. It started our container.

Cool. But now what, how can we talk to this container? Run a command called dock composed PS that shows all of the containers that are running. And the really important thing here to see is that port 5, 4 32 in the container is connected to port 5, 0 7, 0 0 on our host machine. That means if we talk to this port, it will actually talk to that Postgres container. This port here is actually random. You'll see that it'll change every time we restart our container. So for example, because I'm using Postgres. If I wanted to talk to that Postgres database, I could use the P SQL, um,

Command line tool. If you have that installed, say dash user equals symphony dash port equals 5, 0 7 dash host equals 1, 2 7 0 1. So talking to my local machine and then dash password. So it'll ask us to enter the password and then app, because app's the name of our database. I'm getting the user symphony and the app from the stuff that we can figure it here on doctrine. And I'll go ahead and copy the password here. Cuz when I hit this, it asks for the password I paste and we are in, this is actually inside a Postgres inside of that container. Awesome. If you using my SQL, you can run a very similar command to talk to whatever your local password is. I'll type quick to get out of this. Now, another way to do this, let me run Docker PS again, Docker composed PS is because our data, our service is called database that comes from our dock compose at Yamo file. We could run doc compose exec X database, and then basically that same command PSQ dash user symphony dash password, and then app. So this is just kind of an easier way to talk to this container, run PSQ with these things.

And if we type in the change rate password, that's another way to get inside of there. Then you can also do that for my SQL as well. So awesome. So just by running com Doose up, we have a Postgres, we have database container that we can talk to. Now, when you wanna stop your container, you'll run, Doose stop, which basically turns your container off. Or you can run the kind of more common Doose down, which turns off those containers and actually removes them. Then when you want to back up, we can run dock both up dash D and then Docker, PS,

Oops,

And then Docker composed PS

To see it running again. But notice this port, as I mentioned is different. That's gonna be a different random port. Every time we start doctrine, all right, so we have our database container running and we even know what port it's running on and everything. So in theory, we could now configure this database UL to point to the exact right spot, including the right port though. This random port here will be kind of annoying. We'll have to kind of go and find it and update it every time we stop and start Docker. Fortunately, there's a much better way. Thanks to the symphony binary. That's running our web server. I wanna talk about that next.
