# Request

I want to allow users to upvote and downvote a mix, so let's add that feature. This will also be the first time we *update* data on an entity. In our `VinylMix` entity, we created a `$votes` integer property. This will need to run an update query when a user votes. Open `/templates/mix/show.html.twig`. To start, let's just print `{{ mix.votesString }} votes` so we can see that on there. Perfect! To add an upvote and downvote functionality, we *could* use some fancy JavaScript, but we're going to keep it simple by adding a button that posts a form. If you remember, in the first tutorial, we installed the Turbo JavaScript library. So even though we'll use a normal `<form>` tag, Turbo will *automatically* submit it via AJAX. This will make for a nice, smooth experience.

Check this out! Symfony *does* have a form component (we'll talk about that in a future tutorial), but this form is going to be so simple that we don't really need it anyway. So I'm going to create a normal, boring `<form>` tag set to `path()`, and I'll submit this to a new controller method that we still need to create.

Head over to `MixController.php` and create a new `public function` called `vote()`. Above this, we'll add our `#[Route()]` with the URL. I'll say `/mix/{id}/vote`. And then, we'll need to link to this, so I'll give it a name: `app_mix_vote`. We're going to use the same trick we did before and include the ID of the specific vinyl mix we're voting on right now, and we'll have Symfony automatically query for that by adding an argument typehinted with `VinylMix $mix`. And while I don't necessarily *need* to, I'll add the `Response` return type, which I forgot up here. Adding this is just good practice. Inside, just to make sure it's working, let's `dd($mix)`. Cool! Copy the name of this route, go back to the template - `show.html.twig` - and inside `path()`, paste. Next, we'll generate a URL to that route. This requires an ID wildcard, which will be `{id: mix.id}`, and then we'll add `method="POST"`.

Any time you have a form that is changing data on your server, you'll want to have `method="POST"`. And though it's not required,we can also make it so a user can only *post* to this URL by adding `methods: ['POST']` over here. Now, if someone goes to this URL, it would be a GET request and won't match this route. Handy!

Head back over to the form. This isn't going to be a form that actually has fields in it. All we're going to do is put a button here. So let's do that. Add a `<button>` with `type="submit"`, and then some classes for styling. For the text, we'll actually use a Font Awesome icon. I'll add a `<span>` with `class="fa fa-thumbs-up"`. Perfect!

Okay, let's go refresh and... awesome! There's our upvote! And when we click it... beautiful! It hits our endpoint! Notice that the URL didn't change. That's because this actually just submitted via AJAX and then our die statement hit it. But this *is* hitting our new controller. In a second, we're going to add another button with a thumbs down here, so we'll need to figure out which button, up or down, is being pushed. To do that, we can actually say `name="direction"` and then `value="up"`. Now, if we click this button, it will send post data with `direction` set to the value `up`.

But how do we read post data in Symfony? Whenever you need to read anything from the request, like post data, query parameters, uploaded files, or headers, you'll need Symfony's request object, and there are two ways to get it.

The first is by autowiring a service called `RequestStack`, and then you can get the current request by saying `$requestStack = getCurrentRequest()` and calling various methods on it. This works anywhere that you can autowire a service, but in a controller, there's an easier way. I'm going to undo that, and instead, I'll add an argument that is typehinted with `Request`. Get the one from Symfony's HttpFoundation. Then, we'll call it `$request`. This *may* look like `Request` is a service and we're autowiring that service, but `Request` is *not* a service. This is something special that only works with the `Request` class.

We now know *four* different types of arguments that you can have to your controller. One: You can have route wildcards like `$id`. Two: You can autowire services. Three: You can typehint entities. And four: You can typehint the `Request` class. Basically, the `Request` object is so important that Symfony created a special case just for this. And it's kind of beautiful. Our *whole* job as developers is to read the request that's coming in and create a response, so it's pretty cool to have an action method that has a `Request` argument - input `Request` and *output* `Response`.

Anyway, now that we have the `Request` object, there are a lot of different ways to get data off of the request object method. In this case, to get post data, we say `$request->request` and then the name of the post data we want which, in this scenario, is `direction`. We're not going to talk a lot about the `Request` object. Whenever you need to read something from it, just take a look at the documentation. It will tell you how to access the data.

All right, back over here, I'm going to refresh the page... upvote and... got it! Okay, let's get rid of thid `dd` and set this to a direction variable with `$direction =`. If, for some reason, direction is missing (this shouldn't happen unless someone is attempting to mess with our site), we'll default it to `up`. So if a `direction` post parameter isn't found, this will return `up` as the default. Now let's add the downvote. Copy this entire button... paste... and all we need to do is change the button icon class name to `fa fa-thumbs-down`.

Okay, the value will either be `up` or `down`. In our controller, we can use this. Say `if ($direction === 'up')`, then `$mix->setVotes($mix->getVotes() + 1)`, `else`, we'll do the same thing, except this will be `- 1`. Then, down here, I'm going to `dd($mix)`. Once again, on a real site, you'll probably also store which user is voting so that the same user can't vote over and over again. We'll learn how to do that in the next tutorial about Doctrine Relations, but this will work just fine for now.

All right, let's go over and refresh. We have 49 votes right now. If we click the upvote button... 50! If we refresh and click downvote... 48! *But*, we haven't saved this value to the database yet. You may have noticed that when I refreshed, the value is still the original "49".

Next, let's save this value and also learn how to redirect, set flash messages, and create smart entity methods to make our controller look a lot cooler than it does now.
