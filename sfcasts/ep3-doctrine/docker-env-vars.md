# Docker Env Vars

Coming soon...

We now have a Postgres database running inside of a Docker container. We can see it by running dock post PS. This also shows us that if we want to talk to this database, we can talk to port 5, 0 7, 3 9. That will be a different port on you for you, because it's a, because that port is randomly chosen when we start a container. And if we wanted to talk to this database directly, like run some commands inside of it, we could use Dr. Composose do that. Dr. Compos exec, and then the name of the service database that comes from the key inside of Doose YAML. And then just the command you wanna go run inside of it. So for us, since this is Postgres, we could use, for example, P sql.ps, user symphony password. So we'll ask us the password and then the name of the database, which is app, both the user symphony and the name of the database app. Those just come from our configuration inside of our dock. Compose that Yamo file. The password has changed me. I'll copy that. We hit paste. It asks us for the password and we are in. So if you need to talk directly at database, you can, and of course you can also do that from my SQL. I'll run quick to get outta that.

So to get our actual application, to point to this database, that's running on this port, we could go into down end and customize this accordingly, like user symphony password change me. And then we could change this port here to be whatever our actual dynamic port is there, but it turns out we don't need to do that because this database URL environment variable is already being correctly set. When we started our project, we started a local dev server using the symphony binary, just to remind you, I'm gonna run symphony server stop to actually stop that web server. And then we'll rerun symphony serve dash D to start that web server. Well, it turns out that the symphony binary, the symphony dev server has special Docker integration watch over here now that when you refresh, you're now seeing the bottom right corner, it's got it's green. And it says en VAs from Docker in short, the symphony binary noticed that Docker was running and has exposed a new environment. Variable that's pointing to it here. I'll show you open up public slash index dot PHP. Or this is our front controller. We're not usually worry about this, but, and inside this little callback, do a DD for dump and die, and we're gonna dump and die. These server super global, this contains lots of different information, including the environment variables that are currently set.

So go over, refresh any page and then search for database underscore U R L and check it out. There it is. This is not the value that we have in our dot end file. Notice the port here, port is not what we have inside of here, but it is the correct port, but it is the correct port for talking to my local database container. So step one, symphony binary detects that Docker is running and then two, it sets a real database underscore URL environment, variable that points to that container. And that's it doctrine knows to read this environment variable. And remember, since this is a real environment, variable it'll override any value that we have in our dot N or dot N dot local files. So in other words, just by starting Docker, our local development, everything is already set up for us. If you wanna see what other environment variables, the symphony local binary setting, you can run symphony VAR export dash dash multiline, but the most important one by far is database underscoring URL. So doctrine is configured and ready next. Let's actually create the database via a bin console command. And we, when we do that, we'll learn a trick for doing that with the symphony binary.
